<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stable AR Viewer</title>
    
    <!-- Three.js for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }
        
        #camera-feed {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            z-index: 1;
        }
        
        #ar-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 2;
            pointer-events: auto;
        }
        
        .ar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
        }
        
        .ar-header {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            z-index: 4;
        }
        
        .ar-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .ar-subtitle {
            font-size: 14px;
            opacity: 0.8;
        }
        
        /* Horizontal scrollable bottom controls */
        .ar-controls-container {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            z-index: 4;
            pointer-events: none;
            display: flex;
            justify-content: center;
        }
        
        .ar-controls {
            display: flex;
            gap: 8px;
            padding: 0 20px;
            overflow-x: auto;
            pointer-events: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
            max-width: 100%;
        }
        
        .ar-controls::-webkit-scrollbar {
            display: none;
        }
        
        .ar-button {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 50px;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            min-width: 60px;
            flex-shrink: 0;
            touch-action: manipulation;
            user-select: none;
        }
        
        .ar-button:hover {
            background: rgba(0, 0, 0, 0.9);
        }
        
        .ar-button:active {
            transform: scale(0.95);
        }
        
        /* Horizontal game-style rotation controls */
        .rotation-controls {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 15px;
            pointer-events: auto;
            z-index: 4;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 25px;
            backdrop-filter: blur(10px);
        }
        
        .rotation-button {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 30, 0.8));
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 10px;
            border-radius: 50%;
            font-size: 16px;
            cursor: pointer;
            backdrop-filter: blur(15px);
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            user-select: none;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .rotation-button:hover {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        .rotation-button:active {
            transform: scale(0.95);
        }
        
        /* AR Movement Controls */
        .ar-movement-controls {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
            z-index: 4;
        }
        
        .movement-button {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 12px;
            border-radius: 50%;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            user-select: none;
            transition: all 0.3s ease;
        }
        
        .movement-button:hover {
            background: rgba(102, 126, 234, 0.8);
        }
        
        .ar-instructions {
            position: fixed;
            bottom: 180px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 14px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            z-index: 4;
            opacity: 1;
            transition: opacity 0.5s ease;
        }
        
        .ar-instructions.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 5;
        }
        
        .error {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 5;
        }
        
        .hidden {
            display: none;
        }

        /* Model Information Overlay */
        .model-info-panel {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 280px;
            max-height: 50vh;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 30, 0.8));
            color: white;
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: auto;
            z-index: 4;
            overflow-y: auto;
            transition: transform 0.3s ease, opacity 0.3s ease;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .model-info-panel.hidden {
            transform: translateY(-50%) translateX(-320px);
            opacity: 0;
        }

        .info-section {
            margin-bottom: 15px;
        }

        .info-title {
            font-size: 16px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .info-content {
            font-size: 14px;
            line-height: 1.4;
            opacity: 0.9;
        }

        .hotspot-list {
            list-style: none;
            padding: 0;
        }

        .hotspot-item {
            background: rgba(255, 255, 255, 0.1);
            margin: 5px 0;
            padding: 8px 12px;
            border-radius: 8px;
            border-left: 3px solid #667eea;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .hotspot-item:hover {
            background: rgba(102, 126, 234, 0.2);
            transform: translateX(5px);
        }

        /* Enhanced Progress Bar */
        .progress-container {
            width: 100%;
            margin-top: 15px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 3px;
        }

        .progress-text {
            font-size: 12px;
            margin-top: 5px;
            text-align: center;
            opacity: 0.8;
        }

        /* Touch Gesture Hints */
        .gesture-hints {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            backdrop-filter: blur(10px);
            z-index: 4;
            max-width: 200px;
            transition: opacity 0.5s ease;
        }

        .gesture-hints.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* Enhanced AR Button Styles */
        .ar-button.enhanced {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 30, 0.8));
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .ar-button.enhanced:hover {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        /* AR Crosshair for pure AR feel */
        .ar-crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 4;
            opacity: 0.6;
        }

        .ar-crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <!-- Camera Feed -->
    <video id="camera-feed" autoplay muted playsinline></video>
    
    <!-- 3D Canvas -->
    <canvas id="ar-canvas"></canvas>
    
    <!-- Loading Screen -->
    <div id="loading" class="loading">
        <div class="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div class="progress-text" id="progress-text">Initializing AR experience...</div>
        </div>
    </div>
    
    <!-- Error Screen -->
    <div id="error" class="error hidden">
        <div>Camera Access Required</div>
        <div style="margin-top: 10px; font-size: 12px;">Please allow camera access for AR</div>
    </div>
    
    <!-- AR Overlay -->
    <div class="ar-overlay">
        <!-- Header Info -->
        <div class="ar-header">
            <div class="ar-title" id="model-title">Loading...</div>
            <div class="ar-subtitle" id="model-subtitle">Move around the model with directional controls</div>
        </div>
        
        <!-- AR Crosshair for pure AR feel -->
        <div class="ar-crosshair"></div>
        
        <!-- Instructions -->
        <div id="ar-instructions" class="ar-instructions">
            üì± Use directional buttons to move the model - Size remains constant
        </div>

        <!-- Model Information Panel -->
        <div class="model-info-panel hidden" id="info-panel">
            <div class="info-section">
                <div class="info-title">
                    <span>üìã</span>
                    <span>Model Overview</span>
                </div>
                <div class="info-content" id="overview-content">
                    Select a model to see detailed information about its structure and functionality.
                </div>
            </div>
            
            <div class="info-section">
                <div class="info-title">
                    <span>üîß</span>
                    <span>Key Components</span>
                </div>
                <ul class="hotspot-list" id="components-list">
                    <li class="hotspot-item">Loading components...</li>
                </ul>
            </div>
            
            <div class="info-section">
                <div class="info-title">
                    <span>‚ö°</span>
                    <span>Performance</span>
                </div>
                <div class="info-content" id="performance-content">
                    Optimized for smooth AR experience
                </div>
            </div>
        </div>

        <!-- Touch Gesture Hints -->
        <div class="gesture-hints" id="gesture-hints">
            <div><strong>AR Controls:</strong></div>
            <div>‚Ä¢ Use directional buttons to move</div>
            <div>‚Ä¢ Drag to manually rotate</div>
            <div>‚Ä¢ Double tap to reset</div>
        </div>

        <!-- AR Movement Controls -->
        <div class="ar-movement-controls">
            <button class="movement-button" onmousedown="moveModel('up')" onmouseup="stopModelMovement()" ontouchstart="moveModel('up')" ontouchend="stopModelMovement()">
                ‚¨ÜÔ∏è
            </button>
            <button class="movement-button" onmousedown="moveModel('left')" onmouseup="stopModelMovement()" ontouchstart="moveModel('left')" ontouchend="stopModelMovement()">
                ‚¨ÖÔ∏è
            </button>
            <button class="movement-button" onmousedown="moveModel('right')" onmouseup="stopModelMovement()" ontouchstart="moveModel('right')" ontouchend="stopModelMovement()">
                ‚û°Ô∏è
            </button>
            <button class="movement-button" onmousedown="moveModel('down')" onmouseup="stopModelMovement()" ontouchstart="moveModel('down')" ontouchend="stopModelMovement()">
                ‚¨áÔ∏è
            </button>
        </div>
        
        <!-- Horizontal Game-style Rotation Controls -->
        <div class="rotation-controls">
            <button class="rotation-button" onmousedown="startRotation('left')" onmouseup="stopRotation()" ontouchstart="startRotation('left')" ontouchend="stopRotation()">
                ‚Ü∫
            </button>
            <button class="rotation-button" onmousedown="startRotation('up')" onmouseup="stopRotation()" ontouchstart="startRotation('up')" ontouchend="stopRotation()">
                ‚¨ÜÔ∏è
            </button>
            <button class="rotation-button" onmousedown="startRotation('down')" onmouseup="stopRotation()" ontouchstart="startRotation('down')" ontouchend="stopRotation()">
                ‚¨áÔ∏è
            </button>
            <button class="rotation-button" onmousedown="startRotation('right')" onmouseup="stopRotation()" ontouchstart="startRotation('right')" ontouchend="stopRotation()">
                ‚Üª
            </button>
        </div>
        
        <!-- Horizontal Scrollable Bottom Controls -->
        <div class="ar-controls-container">
            <div class="ar-controls">
                <button class="ar-button enhanced" onclick="resetView()" type="button">
                    <span>üîÑ</span>
                    <span>Reset</span>
                </button>
                <button class="ar-button enhanced" onclick="moveNear()" type="button">
                    <span>üîç</span>
                    <span>Near</span>
                </button>
                <button class="ar-button enhanced" onclick="moveFar()" type="button">
                    <span>üî≠</span>
                    <span>Far</span>
                </button>
                <button class="ar-button enhanced" onclick="toggleInfoPanel()" type="button">
                    <span>üìã</span>
                    <span>Info</span>
                </button>
                <button class="ar-button enhanced" onclick="captureARScreenshot()" type="button">
                    <span>üì∏</span>
                    <span>Capture</span>
                </button>
                <button class="ar-button enhanced" onclick="closeAR()" type="button">
                    <span>‚ùå</span>
                    <span>Close</span>
                </button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, model;
        let currentSize = 1;
        let modelData = {};
        let cameraStream = null;
        let isAutoRotating = false;
        
        // Rotation variables
        let rotationInterval = null;
        let currentRotationDirection = null;
        const ROTATION_SPEED = 0.05;

        // Model movement variables
        let modelMovementInterval = null;
        let currentModelMovement = null;
        const MODEL_MOVEMENT_SPEED = 0.2;

        // Touch gesture variables
        let touchStartDistance = 0;
        let touchStartTime = 0;
        let lastTouchTime = 0;
        let touchCount = 0;
        let lastTouchX = 0;
        let lastTouchY = 0;

        // Model position tracking
        let modelPosition = { x: 0, y: 0, z: -15 };
        
        // Enhanced model data with detailed information
        const ENHANCED_MODEL_DATA = {
            array: {
                overview: "Arrays are fundamental linear data structures that store elements in contiguous memory locations. They provide O(1) random access through indexing and are the building blocks for many other data structures.",
                components: ["Index-based Access", "Contiguous Memory Layout", "Fixed Size Allocation", "Homogeneous Elements", "Cache-Friendly Design"],
                performance: "Access: O(1), Search: O(n), Insert/Delete: O(n)",
                useCases: "Database records, image processing, mathematical computations, buffer implementations"
            },
            binary_tree: {
                overview: "Binary trees are hierarchical data structures where each node has at most two children. They form the foundation for efficient searching, sorting, and hierarchical data organization.",
                components: ["Root Node", "Parent-Child Relationships", "Left/Right Subtrees", "Leaf Nodes", "Tree Traversal Methods"],
                performance: "Search: O(log n), Insert: O(log n), Delete: O(log n)",
                useCases: "File systems, expression parsing, decision trees, database indexing"
            },
            linked_list: {
                overview: "Linked lists are dynamic linear data structures where elements (nodes) are connected through pointers. They allow efficient insertion and deletion at any position.",
                components: ["Node Structure", "Pointer References", "Head/Tail Pointers", "Dynamic Memory", "Sequential Access"],
                performance: "Access: O(n), Search: O(n), Insert: O(1), Delete: O(1)",
                useCases: "Dynamic memory allocation, undo functionality, music playlists, browser history"
            },
            stack: {
                overview: "Stacks follow the Last-In-First-Out (LIFO) principle. Elements are added and removed from the same end, making them perfect for managing function calls and temporary data.",
                components: ["Top Pointer", "LIFO Operations", "Push/Pop Methods", "Stack Frame", "Overflow Protection"],
                performance: "Push: O(1), Pop: O(1), Peek: O(1), Search: O(n)",
                useCases: "Function call management, expression evaluation, undo operations, browser back button"
            },
            queue: {
                overview: "Queues implement the First-In-First-Out (FIFO) principle. Elements are added at the rear and removed from the front, ideal for scheduling and buffering.",
                components: ["Front/Rear Pointers", "FIFO Operations", "Enqueue/Dequeue", "Circular Implementation", "Buffer Management"],
                performance: "Enqueue: O(1), Dequeue: O(1), Front: O(1), Search: O(n)",
                useCases: "Task scheduling, print queues, breadth-first search, CPU scheduling"
            },
            merge_sort: {
                overview: "Merge Sort is a divide-and-conquer algorithm that recursively divides the array into halves, sorts them, and merges them back together in sorted order.",
                components: ["Divide Phase", "Conquer Phase", "Merge Operation", "Recursive Structure", "Stable Sorting"],
                performance: "Time: O(n log n), Space: O(n), Stable: Yes",
                useCases: "Large dataset sorting, external sorting, stable sorting requirements, parallel processing"
            },
            osi_model: {
                overview: "The OSI (Open Systems Interconnection) model is a conceptual framework that standardizes network communication into seven distinct layers.",
                components: ["Physical Layer", "Data Link Layer", "Network Layer", "Transport Layer", "Session Layer", "Presentation Layer", "Application Layer"],
                performance: "Standardized communication, protocol independence, modular design",
                useCases: "Network troubleshooting, protocol development, network education, system design"
            },
            client_server: {
                overview: "Client-Server architecture is a distributed computing model where clients request services from centralized servers, enabling scalable and manageable systems.",
                components: ["Client Applications", "Server Infrastructure", "Request/Response Cycle", "Load Balancing", "Database Integration"],
                performance: "Scalable, centralized management, resource sharing, fault tolerance",
                useCases: "Web applications, database systems, email services, file sharing, enterprise applications"
            },
            firewall: {
                overview: "Firewalls are network security systems that monitor and control incoming and outgoing traffic based on predetermined security rules and policies.",
                components: ["Packet Filtering", "Stateful Inspection", "Application Gateway", "Rule Engine", "Logging System"],
                performance: "Real-time filtering, high throughput, minimal latency impact",
                useCases: "Network perimeter security, internal segmentation, malware protection, compliance enforcement"
            },
            router: {
                overview: "Routers are networking devices that forward data packets between computer networks, determining the best path for data transmission.",
                components: ["Routing Table", "Packet Forwarding", "Protocol Support", "Interface Management", "Quality of Service"],
                performance: "High-speed packet processing, dynamic routing, load balancing",
                useCases: "Internet connectivity, network segmentation, traffic management, VPN connections"
            }
        };
        
        const AR_CONFIG = {
            // Initial model position - centered and far enough to be fully visible
            INITIAL_MODEL_POSITION: { x: 0, y: 0, z: -90},
            
            // Camera settings
            CAMERA_POSITION: { x: 0, y: 0, z: 0 },
            CAMERA_FOV: 75,
            
            // Model sizing - fixed size regardless of position
            INITIAL_SCALE: 3.5,
            
            // Auto rotation
            AUTO_ROTATE: false,
            ROTATION_SPEED: 0.01
        };
        
        // Model configurations
        const MODEL_CONFIGS = {
    array: {
        title: "Array Data Structure",
        subtitle: "Linear collection of elements with indexed access",
        model: "file:///android_asset/models/array.glb",
        scale: AR_CONFIG.INITIAL_SCALE
    },
    binary_tree: {
        title: "Binary Tree",
        subtitle: "Hierarchical structure with parent-child relationships",
        model: "file:///android_asset/models/binary_tree.glb",
        scale: AR_CONFIG.INITIAL_SCALE
    },
    linked_list: {
        title: "Linked List",
        subtitle: "Sequential nodes connected via pointers",
        model: "file:///android_asset/models/linked_list.glb",
        scale: AR_CONFIG.INITIAL_SCALE
    },
    stack: {
        title: "Stack (LIFO)",
        subtitle: "Last In First Out data structure",
        model: "file:///android_asset/models/stack.glb",
        scale: AR_CONFIG.INITIAL_SCALE
    },
    queue: {
        title: "Queue (FIFO)",
        subtitle: "First In First Out data structure",
        model: "file:///android_asset/models/queue.glb",
        scale: AR_CONFIG.INITIAL_SCALE
    },
    merge_sort: {
        title: "Merge Sort Algorithm",
        subtitle: "Divide and conquer sorting technique",
        model: "file:///android_asset/models/merge_sort.glb",
        scale: AR_CONFIG.INITIAL_SCALE
    },
    osi_model: {
        title: "OSI Model",
        subtitle: "7-layer network communication framework",
        model: "file:///android_asset/models/osi_model.glb",
        scale: AR_CONFIG.INITIAL_SCALE
    },
    client_server: {
        title: "Client-Server Architecture",
        subtitle: "Distributed computing model",
        model: "file:///android_asset/models/client_server.glb",
        scale: AR_CONFIG.INITIAL_SCALE
    },
    firewall: {
        title: "Network Firewall",
        subtitle: "Security barrier for network traffic",
        model: "file:///android_asset/models/firewall.glb",
        scale: AR_CONFIG.INITIAL_SCALE
    },
    router: {
        title: "Network Router",
        subtitle: "Data packet forwarding device",
        model: "file:///android_asset/models/router.glb",
        scale: AR_CONFIG.INITIAL_SCALE
    }
};
        
        // Initialize AR
        document.addEventListener('DOMContentLoaded', function() {
            initializeAR();
        });
        
        async function initializeAR() {
            try {
                // Get model name from URL parameters
                const urlParams = new URLSearchParams(window.location.search);
                const modelName = urlParams.get('model') || 'array';
                
                console.log('Initializing AR with model:', modelName);
                
                // Set model data
                modelData = MODEL_CONFIGS[modelName] || MODEL_CONFIGS.array;
                
                // Update UI
                updateUI();

                // Initialize enhanced features
                initTouchGestures();
                updateModelInfo();
                hideGestureHints();
                
                // Initialize camera
                updateProgress(10, 'Initializing camera...');
                await initCamera();
                
                // Initialize 3D scene
                updateProgress(30, 'Setting up AR scene...');
                initThreeJS();
                
                // Load 3D model
                updateProgress(60, 'Loading 3D model...');
                await loadModel(modelName);
                
                // Start render loop
                animate();
                
                // Hide loading screen
                document.getElementById('loading').classList.add('hidden');
                
                // Hide instructions after 10 seconds
                setTimeout(() => {
                    document.getElementById('ar-instructions').classList.add('hidden');
                }, 10000);

                updateProgress(90, 'Applying AR enhancements...');
                updateProgress(100, 'AR experience ready!');
                
            } catch (error) {
                console.error('AR initialization failed:', error);
                showError('Failed to initialize AR experience');
            }
        }

        // Enhanced progress tracking
        function updateProgress(percent, message = '') {
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            
            if (progressFill) {
                progressFill.style.width = percent + '%';
            }
            
            if (progressText && message) {
                progressText.textContent = message;
            }
        }

        // Enhanced touch gesture handling
        function initTouchGestures() {
            const canvas = document.getElementById('ar-canvas');
            
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
            
            // Mouse events for desktop testing
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            
            console.log('‚úÖ AR touch gestures initialized');
        }

        function handleTouchStart(event) {
            event.preventDefault();
            touchCount = event.touches.length;
            touchStartTime = Date.now();
            
            if (touchCount === 1) {
                lastTouchX = event.touches[0].clientX;
                lastTouchY = event.touches[0].clientY;
            }
            
            if (touchCount === 2) {
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                touchStartDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
            }
        }

        function handleTouchMove(event) {
            event.preventDefault();
            
            if (touchCount === 1 && event.touches.length === 1) {
                // Single finger drag - rotate model
                const deltaX = event.touches[0].clientX - lastTouchX;
                const deltaY = event.touches[0].clientY - lastTouchY;
                
                const sensitivity = 0.005;
                if (model) {
                    model.rotation.y += deltaX * sensitivity;
                    model.rotation.x += deltaY * sensitivity;
                }
                
                lastTouchX = event.touches[0].clientX;
                lastTouchY = event.touches[0].clientY;
            }
            
            if (touchCount === 2 && event.touches.length === 2) {
                // Two finger pinch - zoom in/out
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                const scale = currentDistance / touchStartDistance;
                
                if (scale > 1.1) {
                    moveNear();
                    touchStartDistance = currentDistance;
                } else if (scale < 0.9) {
                    moveFar();
                    touchStartDistance = currentDistance;
                }
            }
        }

        function handleTouchEnd(event) {
            const touchDuration = Date.now() - touchStartTime;
            
            // Double tap detection
            const currentTime = Date.now();
            const timeDiff = currentTime - lastTouchTime;
            
            if (timeDiff < 300 && timeDiff > 0 && touchDuration < 200) {
                resetView();
                event.preventDefault();
            }
            
            // Long press detection (800ms)
            if (touchDuration > 800 && touchCount === 1) {
                toggleInfoPanel();
            }
            
            lastTouchTime = currentTime;
            touchCount = 0;
        }

        // Mouse events for desktop
        let isMouseDown = false;

        function handleMouseDown(event) {
            isMouseDown = true;
            lastTouchX = event.clientX;
            lastTouchY = event.clientY;
        }

        function handleMouseMove(event) {
            if (!isMouseDown) return;
            
            const deltaX = event.clientX - lastTouchX;
            const deltaY = event.clientY - lastTouchY;
            
            const sensitivity = 0.005;
            if (model) {
                model.rotation.y += deltaX * sensitivity;
                model.rotation.x += deltaY * sensitivity;
            }
            
            lastTouchX = event.clientX;
            lastTouchY = event.clientY;
        }

        function handleMouseUp(event) {
            isMouseDown = false;
        }

        // Model movement functions - FIXED SIZE, ONLY POSITION CHANGES
        function moveModel(direction) {
            stopModelMovement();
            currentModelMovement = direction;
            
            modelMovementInterval = setInterval(() => {
                if (model) {
                    const speed = MODEL_MOVEMENT_SPEED;
                    
                    switch(direction) {
                        case 'up':
                            modelPosition.y += speed;
                            break;
                        case 'down':
                            modelPosition.y -= speed;
                            break;
                        case 'left':
                            modelPosition.x -= speed;
                            break;
                        case 'right':
                            modelPosition.x += speed;
                            break;
                    }
                    
                    // Update model position WITHOUT changing scale
                    model.position.set(
                        modelPosition.x,
                        modelPosition.y,
                        modelPosition.z
                    );
                }
            }, 16);
        }

        function stopModelMovement() {
            if (modelMovementInterval) {
                clearInterval(modelMovementInterval);
                modelMovementInterval = null;
                currentModelMovement = null;
            }
        }

        // Enhanced model information
        function updateModelInfo() {
            const modelName = Object.keys(MODEL_CONFIGS).find(key => 
                MODEL_CONFIGS[key] === modelData
            );
            
            const enhancedData = ENHANCED_MODEL_DATA[modelName];
            if (!enhancedData) return;
            
            // Update overview
            const overviewContent = document.getElementById('overview-content');
            if (overviewContent) {
                overviewContent.textContent = enhancedData.overview;
            }
            
            // Update components list
            const componentsList = document.getElementById('components-list');
            if (componentsList) {
                componentsList.innerHTML = '';
                enhancedData.components.forEach((component, index) => {
                    const li = document.createElement('li');
                    li.className = 'hotspot-item';
                    li.textContent = component;
                    li.onclick = () => highlightComponent(index);
                    componentsList.appendChild(li);
                });
            }
            
            // Update performance info
            const performanceContent = document.getElementById('performance-content');
            if (performanceContent) {
                performanceContent.innerHTML = `
                    <div><strong>Complexity:</strong> ${enhancedData.performance}</div>
                    <div><strong>Use Cases:</strong> ${enhancedData.useCases}</div>
                `;
            }
        }

        function highlightComponent(index) {
            // Add visual highlight effect to model component
            if (model && model.children[index]) {
                const component = model.children[index];
                
                // Create highlight effect
                const originalMaterial = component.material;
                const highlightMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x667eea,
                    transparent: true,
                    opacity: 0.7
                });
                
                component.material = highlightMaterial;
                
                setTimeout(() => {
                    component.material = originalMaterial;
                }, 2000);
            }
        }

        // Enhanced screenshot with AR background
        function captureARScreenshot() {
            try {
                const video = document.getElementById('camera-feed');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                // Draw camera feed as background
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // Draw 3D scene on top
                ctx.globalCompositeOperation = 'source-over';
                ctx.drawImage(renderer.domElement, 0, 0);
                
                // Create download link
                const link = document.createElement('a');
                const filename = `AR_${modelData.title.replace(/\s+/g, '_')}_${Date.now()}.png`;
                link.download = filename;
                link.href = canvas.toDataURL('image/png');
                link.click();
                
                // Visual feedback only
                const button = event.target.closest('.ar-button');
                const originalText = button.querySelector('span:last-child').textContent;
                button.querySelector('span:last-child').textContent = 'Saved!';
                button.style.background = 'linear-gradient(135deg, #4CAF50 0%, #45a049 100%)';
                
                setTimeout(() => {
                    button.querySelector('span:last-child').textContent = originalText;
                    button.style.background = '';
                }, 2000);
                
                console.log('‚úÖ AR screenshot saved:', filename);
            } catch (error) {
                console.error('Screenshot error:', error);
            }
        }

        // Toggle info panel
        function toggleInfoPanel() {
            const panel = document.getElementById('info-panel');
            panel.classList.toggle('hidden');
        }

        // Hide gesture hints after delay
        function hideGestureHints() {
            setTimeout(() => {
                const hints = document.getElementById('gesture-hints');
                if (hints) {
                    hints.classList.add('hidden');
                }
            }, 15000); // Hide after 15 seconds
        }
        
        async function initCamera() {
            try {
                const video = document.getElementById('camera-feed');
                
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('Camera not supported');
                }
                
                cameraStream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
                
                video.srcObject = cameraStream;
                
                return new Promise((resolve, reject) => {
                    video.onloadedmetadata = () => {
                        video.play().then(resolve).catch(reject);
                    };
                    video.onerror = reject;
                });
                
            } catch (error) {
                console.error('Camera initialization failed:', error);
                throw new Error('Camera access denied');
            }
        }
        
        function initThreeJS() {
            const canvas = document.getElementById('ar-canvas');
            
            // Scene
            scene = new THREE.Scene();
            
            // Camera setup - fixed position
            camera = new THREE.PerspectiveCamera(
                AR_CONFIG.CAMERA_FOV, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                1000
            );
            
            // Set camera position
            camera.position.set(
                AR_CONFIG.CAMERA_POSITION.x,
                AR_CONFIG.CAMERA_POSITION.y,
                AR_CONFIG.CAMERA_POSITION.z
            );
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                alpha: true,
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Enhanced lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(10, 10, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Additional lights for better visibility
            const light2 = new THREE.DirectionalLight(0xffffff, 0.6);
            light2.position.set(-10, 5, -10);
            scene.add(light2);
            
            const light3 = new THREE.DirectionalLight(0xffffff, 0.5);
            light3.position.set(0, -10, 0);
            scene.add(light3);
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            console.log('‚úÖ AR setup complete');
        }
        
        async function loadModel(modelName) {
            return new Promise((resolve, reject) => {
                const loader = new THREE.GLTFLoader();
                
                console.log('Loading model from:', modelData.model);
                
                loader.load(
                    modelData.model,
                    (gltf) => {
                        model = gltf.scene;
                        
                        // Initialize model position
                        modelPosition = { ...AR_CONFIG.INITIAL_MODEL_POSITION };
                        
                        // Set model position
                        model.position.set(
                            modelPosition.x,
                            modelPosition.y,
                            modelPosition.z
                        );
                        
                        // Set model scale - FIXED SIZE
                        model.scale.setScalar(modelData.scale * currentSize);
                        
                        // Set initial rotation
                        model.rotation.set(0, 0, 0);
                        
                        // Enable shadows
                        model.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });
                        
                        // Add to scene
                        scene.add(model);
                        
                        console.log('‚úÖ Model loaded at position:', model.position);
                        
                        // Send message to React Native
                        if (window.ReactNativeWebView) {
                            window.ReactNativeWebView.postMessage(JSON.stringify({
                                type: 'model_loaded',
                                modelName: modelName
                            }));
                        }
                        
                        resolve();
                    },
                    (progress) => {
                        console.log('Loading progress:', progress);
                    },
                    (error) => {
                        console.error('Model loading failed:', error);
                        createFallbackModel(modelName);
                        resolve();
                    }
                );
            });
        }
        
        function createFallbackModel(modelName) {
            let geometry, material;
            
            switch(modelName) {
                case 'array':
                    const group = new THREE.Group();
                    for(let i = 0; i < 7; i++) {
                        const boxGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
                        const boxMaterial = new THREE.MeshLambertMaterial({ 
                            color: new THREE.Color().setHSL(i * 0.15, 0.7, 0.6)
                        });
                        const box = new THREE.Mesh(boxGeometry, boxMaterial);
                        box.position.x = (i - 3) * 0.5;
                        box.castShadow = true;
                        group.add(box);
                    }
                    model = group;
                    break;
                    
                case 'osi_model':
                    const osiGroup = new THREE.Group();
                    const layers = ['Physical', 'Data Link', 'Network', 'Transport', 'Session', 'Presentation', 'Application'];
                    for(let i = 0; i < 7; i++) {
                        const layerGeometry = new THREE.BoxGeometry(1, 0.2, 0.8);
                        const layerMaterial = new THREE.MeshLambertMaterial({ 
                            color: new THREE.Color().setHSL(i * 0.14, 0.8, 0.6)
                        });
                        const layer = new THREE.Mesh(layerGeometry, layerMaterial);
                        layer.position.y = i * 0.25 - 0.75;
                        layer.castShadow = true;
                        osiGroup.add(layer);
                    }
                    model = osiGroup;
                    break;
                    
                default:
                    geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                    material = new THREE.MeshLambertMaterial({ color: 0x9C27B0 });
                    model = new THREE.Mesh(geometry, material);
                    break;
            }
            
            // Initialize model position
            modelPosition = { ...AR_CONFIG.INITIAL_MODEL_POSITION };
            
            // Set model position
            model.position.set(
                modelPosition.x,
                modelPosition.y,
                modelPosition.z
            );
            
            // Set model scale - FIXED SIZE
            model.scale.setScalar(modelData.scale * currentSize);
            
            // Set initial rotation
            model.rotation.set(0, 0, 0);
            
            // Enable shadows
            model.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            
            scene.add(model);
            console.log('‚úÖ Fallback model created at position:', model.position);
        }
        
        function updateUI() {
            document.getElementById('model-title').textContent = modelData.title;
            document.getElementById('model-subtitle').textContent = modelData.subtitle;
            updateModelInfo();
        }
        
        // Rotation functions - Rotate the MODEL
        function startRotation(direction) {
            stopRotation();
            currentRotationDirection = direction;
            
            rotationInterval = setInterval(() => {
                if (model) {
                    switch(direction) {
                        case 'up':
                            model.rotation.x -= ROTATION_SPEED;
                            break;
                        case 'down':
                            model.rotation.x += ROTATION_SPEED;
                            break;
                        case 'left':
                            model.rotation.y += ROTATION_SPEED;
                            break;
                        case 'right':
                            model.rotation.y -= ROTATION_SPEED;
                            break;
                    }
                }
            }, 16);
        }
        
        function stopRotation() {
            if (rotationInterval) {
                clearInterval(rotationInterval);
                rotationInterval = null;
                currentRotationDirection = null;
            }
        }
        
        function changeSize() {
            try {
                if (model) {
                    if (currentSize <= 0.5) {
                        currentSize = 1;
                    } else if (currentSize <= 1) {
                        currentSize = 1.5;
                    } else if (currentSize <= 1.5) {
                        currentSize = 2;
                    } else {
                        currentSize = 0.5;
                    }
                    
                    model.scale.setScalar(modelData.scale * currentSize);
                    
                    const sizeText = document.getElementById('size-text');
                    if (sizeText) {
                        sizeText.textContent = `${currentSize}x`;
                        setTimeout(() => {
                            if (sizeText) {
                                sizeText.textContent = 'Size';
                            }
                        }, 2000);
                    }
                }
            } catch (error) {
                console.error('Size change error:', error);
            }
        }
        
        // Distance controls - FIXED SIZE, ONLY Z POSITION CHANGES
        function moveNear() {
            try {
                if (model) {
                    modelPosition.z += 1;
                    model.position.z = modelPosition.z;
                    console.log('Model moved closer:', modelPosition.z);
                }
            } catch (error) {
                console.error('Move near error:', error);
            }
        }
        
        function moveFar() {
            try {
                if (model) {
                    modelPosition.z -= 1;
                    model.position.z = modelPosition.z;
                    console.log('Model moved farther:', modelPosition.z);
                }
            } catch (error) {
                console.error('Move far error:', error);
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Auto rotation of the MODEL
            if (model && isAutoRotating) {
                model.rotation.y += AR_CONFIG.ROTATION_SPEED;
            }
            
            // Render the scene
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function resetView() {
            try {
                if (model) {
                    // Reset model rotation
                    model.rotation.set(0, 0, 0);
                    
                    // Reset model position
                    modelPosition = { ...AR_CONFIG.INITIAL_MODEL_POSITION };
                    model.position.set(
                        modelPosition.x,
                        modelPosition.y,
                        modelPosition.z
                    );
                    
                    console.log('‚úÖ AR view reset');
                }
            } catch (error) {
                console.error('Reset error:', error);
            }
        }
        
        function closeAR() {
            try {
                stopRotation();
                stopModelMovement();
                if (cameraStream) {
                    cameraStream.getTracks().forEach(track => track.stop());
                }
                if (window.ReactNativeWebView) {
                    window.ReactNativeWebView.postMessage(JSON.stringify({
                        type: 'close_ar'
                    }));
                }
            } catch (error) {
                console.error('Close AR error:', error);
            }
        }
        
        function showError(message) {
            document.getElementById('loading').classList.add('hidden');
            const errorDiv = document.getElementById('error');
            if (errorDiv) {
                const errorText = errorDiv.querySelector('div');
                if (errorText) {
                    errorText.textContent = message;
                }
                errorDiv.classList.remove('hidden');
            }
        }
        
        // Handle messages from React Native
        window.addEventListener('message', function(event) {
            try {
                const data = JSON.parse(event.data);
                switch(data.type) {
                    case 'change_model':
                        changeModel(data.modelName);
                        break;
                    case 'reset_view':
                        resetView();
                        break;
                }
            } catch (error) {
                console.error('Error handling message:', error);
            }
        });
        
        async function changeModel(newModelName) {
            try {
                if (model) {
                    scene.remove(model);
                }
                
                modelData = MODEL_CONFIGS[newModelName] || MODEL_CONFIGS.array;
                updateUI();
                await loadModel(newModelName);
            } catch (error) {
                console.error('Change model error:', error);
            }
        }
        
        // Error handling
        window.addEventListener('error', function(event) {
            console.error('AR Error:', event.error);
            if (!event.error.message.includes('camera')) {
                showError('An error occurred in AR view');
            }
        });
        
        // Handle page visibility change
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                stopRotation();
                stopModelMovement();
                if (cameraStream) {
                    cameraStream.getTracks().forEach(track => track.enabled = false);
                }
            } else {
                if (cameraStream) {
                    cameraStream.getTracks().forEach(track => track.enabled = true);
                }
            }
        });
        
        // Prevent default touch events on buttons
        document.addEventListener('touchstart', function(e) {
            if (e.target.classList.contains('ar-button') || 
                e.target.classList.contains('rotation-button') ||
                e.target.classList.contains('movement-button')) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html>