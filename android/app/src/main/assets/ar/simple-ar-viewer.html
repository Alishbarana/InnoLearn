<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real AR Viewer - Constant Size</title>
    
    <!-- Three.js for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }
        
        #camera-feed {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            z-index: 1;
        }
        
        #ar-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 2;
            pointer-events: auto;
        }
        
        .ar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
        }
        
        .ar-header {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            z-index: 4;
        }
        
        .ar-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .ar-subtitle {
            font-size: 14px;
            opacity: 0.8;
        }
        
        /* Professional Circular Bottom Controls - NO PLATE */
        .bottom-controls {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            z-index: 4;
            pointer-events: none;
            display: flex;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .bottom-controls.visible {
            opacity: 1;
        }

        .controls-scroll {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
            scroll-behavior: smooth;
            padding: 0 10px;
            justify-content: center;
        }

        .controls-scroll::-webkit-scrollbar {
            display: none;
        }

        .control-btn {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 12px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            width: 55px;
            height: 55px;
            flex-shrink: 0;
            touch-action: manipulation;
            user-select: none;
            transition: all 0.2s ease;
            border-radius: 50%;
            pointer-events: auto;
            backdrop-filter: blur(10px);
        }

        .control-btn:hover {
            background: rgba(0, 0, 0, 0.8);
            transform: scale(1.05);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        /* Professional Circular Right Side Panel - NO PLATE */
        .right-panel {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            z-index: 4;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 10px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .right-panel.visible {
            opacity: 1;
        }

        .panel-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .panel-btn {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 12px;
            font-size: 16px;
            cursor: pointer;
            width: 55px;
            height: 55px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            user-select: none;
            transition: all 0.2s ease;
            border-radius: 50%;
            pointer-events: auto;
            backdrop-filter: blur(10px);
        }

        .panel-btn:hover {
            background: rgba(0, 0, 0, 0.8);
            transform: scale(1.05);
        }

        .panel-btn:active {
            transform: scale(0.95);
        }

        /* Circular Rotation Controls - NO PLATE */
        .rotation-controls {
            position: fixed;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 4;
            pointer-events: none;
            display: flex;
            gap: 12px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .rotation-controls.visible {
            opacity: 1;
        }

        .rotation-grid {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .rotation-btn {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            width: 55px;
            height: 55px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            user-select: none;
            transition: all 0.2s ease;
            border-radius: 50%;
            pointer-events: auto;
            backdrop-filter: blur(10px);
        }

        .rotation-btn:hover {
            background: rgba(0, 0, 0, 0.8);
            transform: scale(1.05);
        }

        .rotation-btn:active {
            transform: scale(0.95);
        }
        
        .ar-instructions {
            position: fixed;
            bottom: 160px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 14px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            z-index: 4;
            opacity: 1;
            transition: opacity 0.5s ease;
        }
        
        .ar-instructions.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 5;
        }
        
        .error {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 5;
        }
        
        .hidden {
            display: none;
        }

        /* Model Information Overlay */
        .model-info-panel {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 280px;
            max-height: 50vh;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 30, 0.8));
            color: white;
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: auto;
            z-index: 4;
            overflow-y: auto;
            transition: transform 0.3s ease, opacity 0.3s ease;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .model-info-panel.hidden {
            transform: translateY(-50%) translateX(-320px);
            opacity: 0;
        }

        .info-section {
            margin-bottom: 15px;
        }

        .info-title {
            font-size: 16px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .info-content {
            font-size: 14px;
            line-height: 1.4;
            opacity: 0.9;
        }

        .hotspot-list {
            list-style: none;
            padding: 0;
        }

        .hotspot-item {
            background: rgba(255, 255, 255, 0.1);
            margin: 5px 0;
            padding: 8px 12px;
            border-radius: 8px;
            border-left: 3px solid #667eea;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .hotspot-item:hover {
            background: rgba(102, 126, 234, 0.2);
            transform: translateX(5px);
        }

        /* Enhanced Progress Bar */
        .progress-container {
            width: 100%;
            margin-top: 15px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 3px;
        }

        .progress-text {
            font-size: 12px;
            margin-top: 5px;
            text-align: center;
            opacity: 0.8;
        }

        /* Touch Gesture Hints */
        .gesture-hints {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            backdrop-filter: blur(10px);
            z-index: 4;
            max-width: 200px;
            transition: opacity 0.5s ease;
        }

        .gesture-hints.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* AR Crosshair */
        .ar-crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 4;
            opacity: 0.6;
        }

        .ar-crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
        }
        
        /* Toast notification */
        .toast {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .toast.show {
            opacity: 1;
        }

        /* Controls toggle button */
        .controls-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            width: 55px;
            height: 55px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            z-index: 5;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            transition: all 0.2s ease;
        }
        
        .controls-toggle:hover {
            background: rgba(0, 0, 0, 0.8);
            transform: scale(1.05);
        }
        
        .controls-toggle:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <!-- Camera Feed -->
    <video id="camera-feed" autoplay muted playsinline></video>
    
    <!-- 3D Canvas -->
    <canvas id="ar-canvas"></canvas>
    
    <!-- Loading Screen -->
    <div id="loading" class="loading">
        <div class="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div class="progress-text" id="progress-text">Initializing Real AR experience...</div>
        </div>
    </div>
    
    <!-- Error Screen -->
    <div id="error" class="error hidden">
        <div>Camera Access Required</div>
        <div style="margin-top: 10px; font-size: 12px;">Please allow camera access for AR</div>
    </div>
    
    <!-- Toast Notification -->
    <div id="toast" class="toast"></div>
    
    <!-- AR Overlay -->
    <div class="ar-overlay">
        <!-- Header Info -->
        <div class="ar-header">
            <div class="ar-title" id="model-title">Loading...</div>
            <div class="ar-subtitle" id="model-subtitle">Real AR - Constant Size Movement</div>
        </div>
        
        <!-- AR Crosshair -->
        <div class="ar-crosshair"></div>
        
        <!-- Instructions -->
        <div id="ar-instructions" class="ar-instructions">
            📱 Tap the controls button to show/hide AR controls
        </div>

        <!-- Model Information Panel -->
        <div class="model-info-panel hidden" id="info-panel">
            <div class="info-section">
                <div class="info-title">
                    <span>📋</span>
                    <span>Model Overview</span>
                </div>
                <div class="info-content" id="overview-content">
                    Select a model to see detailed information about its structure and functionality.
                </div>
            </div>
            
            <div class="info-section">
                <div class="info-title">
                    <span>🔧</span>
                    <span>Key Components</span>
                </div>
                <ul class="hotspot-list" id="components-list">
                    <li class="hotspot-item">Loading components...</li>
                </ul>
            </div>
            
            <div class="info-section">
                <div class="info-title">
                    <span>⚡</span>
                    <span>Performance</span>
                </div>
                <div class="info-content" id="performance-content">
                    Optimized for smooth AR experience
                </div>
            </div>
        </div>

        <!-- Touch Gesture Hints -->
        <div class="gesture-hints" id="gesture-hints">
            <div><strong>Real AR Controls:</strong></div>
            <div>• Model keeps constant size</div>
            <div>• Moves through real space</div>
            <div>• Drag to rotate</div>
            <div>• Double tap to reset</div>
        </div>

        <!-- Professional Right Side Panel - NO PLATE -->
        <div class="right-panel" id="right-panel">
            <div class="panel-controls">
                <button class="panel-btn" onmousedown="moveModel('up')" onmouseup="stopModelMovement()" ontouchstart="moveModel('up')" ontouchend="stopModelMovement()">
                    ⬆️
                </button>
                <button class="panel-btn" onmousedown="moveModel('left')" onmouseup="stopModelMovement()" ontouchstart="moveModel('left')" ontouchend="stopModelMovement()">
                    ⬅️
                </button>
                <button class="panel-btn" onmousedown="moveModel('right')" onmouseup="stopModelMovement()" ontouchstart="moveModel('right')" ontouchend="stopModelMovement()">
                    ➡️
                </button>
                <button class="panel-btn" onmousedown="moveModel('down')" onmouseup="stopModelMovement()" ontouchstart="moveModel('down')" ontouchend="stopModelMovement()">
                    ⬇️
                </button>
            </div>
        </div>
        
        <!-- Professional Rotation Controls - NO PLATE -->
        <div class="rotation-controls" id="rotation-controls">
            <div class="rotation-grid">
                <button class="rotation-btn" onmousedown="startRotation('left')" onmouseup="stopRotation()" ontouchstart="startRotation('left')" ontouchend="stopRotation()">
                    ↺
                </button>
                <button class="rotation-btn" onmousedown="startRotation('up')" onmouseup="stopRotation()" ontouchstart="startRotation('up')" ontouchend="stopRotation()">
                    ⬆️
                </button>
                <button class="rotation-btn" onmousedown="startRotation('down')" onmouseup="stopRotation()" ontouchstart="startRotation('down')" ontouchend="stopRotation()">
                    ⬇️
                </button>
                <button class="rotation-btn" onmousedown="startRotation('right')" onmouseup="stopRotation()" ontouchstart="startRotation('right')" ontouchend="stopRotation()">
                    ↻
                </button>
            </div>
        </div>
        
        <!-- Professional Bottom Control Panel - NO PLATE -->
        <div class="bottom-controls" id="bottom-controls">
            <div class="controls-scroll">
                <button class="control-btn" onclick="resetView()" type="button">
                    <span>🔄</span>
                    <span>Reset</span>
                </button>
                <button class="control-btn" onclick="moveNear()" type="button">
                    <span>🔍</span>
                    <span>Near</span>
                </button>
                <button class="control-btn" onclick="moveFar()" type="button">
                    <span>🔭</span>
                    <span>Far</span>
                </button>
                <button class="control-btn" onclick="toggleInfoPanel()" type="button">
                    <span>📋</span>
                    <span>Info</span>
                </button>
                <button class="control-btn" onclick="captureARScreenshot()" type="button">
                    <span>📸</span>
                    <span>Capture</span>
                </button>
                <button class="control-btn" onclick="closeAR()" type="button">
                    <span>❌</span>
                    <span>Close</span>
                </button>
            </div>
        </div>
        
        <!-- Controls Toggle Button
        <button class="controls-toggle" id="controls-toggle" onclick="toggleControls()">
            🎮
        </button> -->
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, model;
        let currentSize = 1;
        let modelData = {};
        let cameraStream = null;
        let isAutoRotating = false;
        let controlsVisible = false;
        
        // Rotation variables
        let rotationInterval = null;
        let currentRotationDirection = null;
        const ROTATION_SPEED = 0.05;

        // Model movement variables
        let modelMovementInterval = null;
        let currentModelMovement = null;
        const MODEL_MOVEMENT_SPEED = 0.3;

        // Touch gesture variables
        let touchStartDistance = 0;
        let touchStartTime = 0;
        let lastTouchTime = 0;
        let touchCount = 0;
        let lastTouchX = 0;
        let lastTouchY = 0;

        // Model position tracking - REAL 3D POSITION with CONSTANT VISUAL SIZE
        let modelPosition = { x: 0, y: 0, z: -75};
        
        // Enhanced model data with detailed information
        const ENHANCED_MODEL_DATA = {
            array: {
                overview: "Arrays are fundamental linear data structures that store elements in contiguous memory locations. They provide O(1) random access through indexing and are the building blocks for many other data structures.",
                components: ["Index-based Access", "Contiguous Memory Layout", "Fixed Size Allocation", "Homogeneous Elements", "Cache-Friendly Design"],
                performance: "Access: O(1), Search: O(n), Insert/Delete: O(n)",
                useCases: "Database records, image processing, mathematical computations, buffer implementations"
            },
            binary_tree: {
                overview: "Binary trees are hierarchical data structures where each node has at most two children. They form the foundation for efficient searching, sorting, and hierarchical data organization.",
                components: ["Root Node", "Parent-Child Relationships", "Left/Right Subtrees", "Leaf Nodes", "Tree Traversal Methods"],
                performance: "Search: O(log n), Insert: O(log n), Delete: O(log n)",
                useCases: "File systems, expression parsing, decision trees, database indexing"
            },
            linked_list: {
                overview: "Linked lists are dynamic linear data structures where elements (nodes) are connected through pointers. They allow efficient insertion and deletion at any position.",
                components: ["Node Structure", "Pointer References", "Head/Tail Pointers", "Dynamic Memory", "Sequential Access"],
                performance: "Access: O(n), Search: O(n), Insert: O(1), Delete: O(1)",
                useCases: "Dynamic memory allocation, undo functionality, music playlists, browser history"
            },
            stack: {
                overview: "Stacks follow the Last-In-First-Out (LIFO) principle. Elements are added and removed from the same end, making them perfect for managing function calls and temporary data.",
                components: ["Top Pointer", "LIFO Operations", "Push/Pop Methods", "Stack Frame", "Overflow Protection"],
                performance: "Push: O(1), Pop: O(1), Peek: O(1), Search: O(n)",
                useCases: "Function call management, expression evaluation, undo operations, browser back button"
            },
            queue: {
                overview: "Queues implement the First-In-First-Out (FIFO) principle. Elements are added at the rear and removed from the front, ideal for scheduling and buffering.",
                components: ["Front/Rear Pointers", "FIFO Operations", "Enqueue/Dequeue", "Circular Implementation", "Buffer Management"],
                performance: "Enqueue: O(1), Dequeue: O(1), Front: O(1), Search: O(n)",
                useCases: "Task scheduling, print queues, breadth-first search, CPU scheduling"
            },
            merge_sort: {
                overview: "Merge Sort is a divide-and-conquer algorithm that recursively divides the array into halves, sorts them, and merges them back together in sorted order.",
                components: ["Divide Phase", "Conquer Phase", "Merge Operation", "Recursive Structure", "Stable Sorting"],
                performance: "Time: O(n log n), Space: O(n), Stable: Yes",
                useCases: "Large dataset sorting, external sorting, stable sorting requirements, parallel processing"
            },
            osi_model: {
                overview: "The OSI (Open Systems Interconnection) model is a conceptual framework that standardizes network communication into seven distinct layers.",
                components: ["Physical Layer", "Data Link Layer", "Network Layer", "Transport Layer", "Session Layer", "Presentation Layer", "Application Layer"],
                performance: "Standardized communication, protocol independence, modular design",
                useCases: "Network troubleshooting, protocol development, network education, system design"
            },
            client_server: {
                overview: "Client-Server architecture is a distributed computing model where clients request services from centralized servers, enabling scalable and manageable systems.",
                components: ["Client Applications", "Server Infrastructure", "Request/Response Cycle", "Load Balancing", "Database Integration"],
                performance: "Scalable, centralized management, resource sharing, fault tolerance",
                useCases: "Web applications, database systems, email services, file sharing, enterprise applications"
            },
            firewall: {
                overview: "Firewalls are network security systems that monitor and control incoming and outgoing traffic based on predetermined security rules and policies.",
                components: ["Packet Filtering", "Stateful Inspection", "Application Gateway", "Rule Engine", "Logging System"],
                performance: "Real-time filtering, high throughput, minimal latency impact",
                useCases: "Network perimeter security, internal segmentation, malware protection, compliance enforcement"
            },
            router: {
                overview: "Routers are networking devices that forward data packets between computer networks, determining the best path for data transmission.",
                components: ["Routing Table", "Packet Forwarding", "Protocol Support", "Interface Management", "Quality of Service"],
                performance: "High-speed packet processing, dynamic routing, load balancing",
                useCases: "Internet connectivity, network segmentation, traffic management, VPN connections"
            }
        };
        
        const AR_CONFIG = {
            // REAL AR POSITIONING with CONSTANT VISUAL SIZE - LARGER MODEL SIZE
            INITIAL_MODEL_POSITION: { x: 0, y: 0, z: -8 },
            REFERENCE_DISTANCE: 8, // Reference distance for scale calculation
            
            // Camera settings
            CAMERA_POSITION: { x: 0, y: 0, z: 0 },
            CAMERA_FOV: 75,
            
            // Model sizing - INCREASED BASE SIZE for better visibility
            BASE_MODEL_SCALE: 2.0, // Increased from 1.2 to 2.0
            
            // Auto rotation
            AUTO_ROTATE: false,
            ROTATION_SPEED: 0.01,
            
            // Movement increments - Original values
            NEAR_FAR_INCREMENT: 3, // Original value
            
            // Screenshot settings
            SCREENSHOT_FOLDER: "/storage/emulated/0/DCIM/ARViewer/"
        };
        
        // Model configurations
        const MODEL_CONFIGS = {
    array: {
        title: "Array Data Structure",
        subtitle: "Linear collection of elements with indexed access",
        model: "file:///android_asset/models/array.glb"
    },
    binary_tree: {
        title: "Binary Tree",
        subtitle: "Hierarchical structure with parent-child relationships",
        model: "file:///android_asset/models/binary_tree.glb"
    },
    linked_list: {
        title: "Linked List",
        subtitle: "Sequential nodes connected via pointers",
        model: "file:///android_asset/models/linked_list.glb"
    },
    stack: {
        title: "Stack (LIFO)",
        subtitle: "Last In First Out data structure",
        model: "file:///android_asset/models/stack.glb"
    },
    queue: {
        title: "Queue (FIFO)",
        subtitle: "First In First Out data structure",
        model: "file:///android_asset/models/queue.glb"
    },
    merge_sort: {
        title: "Merge Sort Algorithm",
        subtitle: "Divide and conquer sorting technique",
        model: "file:///android_asset/models/merge_sort.glb"
    },
    osi_model: {
        title: "OSI Model",
        subtitle: "7-layer network communication framework",
        model: "file:///android_asset/models/osi_model.glb"
    },
    client_server: {
        title: "Client-Server Architecture",
        subtitle: "Distributed computing model",
        model: "file:///android_asset/models/client_server.glb"
    },
    firewall: {
        title: "Network Firewall",
        subtitle: "Security barrier for network traffic",
        model: "file:///android_asset/models/firewall.glb"
    },
    router: {
        title: "Network Router",
        subtitle: "Data packet forwarding device",
        model: "file:///android_asset/models/router.glb"
    }
};
        
        // Initialize AR
        document.addEventListener('DOMContentLoaded', function() {
            initializeAR();
            
            // Auto-hide controls after 5 seconds
            setTimeout(() => {
                hideControls();
            }, 5000);
        });
        
        // Toggle controls visibility
        function toggleControls() {
            controlsVisible = !controlsVisible;
            
            const bottomControls = document.getElementById('bottom-controls');
            const rightPanel = document.getElementById('right-panel');
            const rotationControls = document.getElementById('rotation-controls');
            
            if (controlsVisible) {
                bottomControls.classList.add('visible');
                rightPanel.classList.add('visible');
                rotationControls.classList.add('visible');
            } else {
                bottomControls.classList.remove('visible');
                rightPanel.classList.remove('visible');
                rotationControls.classList.remove('visible');
            }
        }
        
        // Hide controls
        function hideControls() {
            controlsVisible = false;
            
            const bottomControls = document.getElementById('bottom-controls');
            const rightPanel = document.getElementById('right-panel');
            const rotationControls = document.getElementById('rotation-controls');
            
            bottomControls.classList.remove('visible');
            rightPanel.classList.remove('visible');
            rotationControls.classList.remove('visible');
        }
        
        // Show controls
        function showControls() {
            controlsVisible = true;
            
            const bottomControls = document.getElementById('bottom-controls');
            const rightPanel = document.getElementById('right-panel');
            const rotationControls = document.getElementById('rotation-controls');
            
            bottomControls.classList.add('visible');
            rightPanel.classList.add('visible');
            rotationControls.classList.add('visible');
            
            // Auto-hide after 5 seconds of inactivity
            clearTimeout(window.controlsTimeout);
            window.controlsTimeout = setTimeout(() => {
                hideControls();
            }, 5000);
        }

        // Update model scale to maintain constant visual size
        function updateModelScale() {
            if (!model) return;
            
            // Calculate distance from camera
            const distance = Math.abs(modelPosition.z);
            
            // Calculate scale factor to maintain constant visual size
            // As distance increases, scale increases proportionally
            const scaleFactor = distance / AR_CONFIG.REFERENCE_DISTANCE;
            const newScale = AR_CONFIG.BASE_MODEL_SCALE * scaleFactor;
            
            // Apply the calculated scale
            model.scale.setScalar(newScale);
        }
        
        async function initializeAR() {
            try {
                // Get model name from URL parameters
                const urlParams = new URLSearchParams(window.location.search);
                const modelName = urlParams.get('model') || 'array';
                
                console.log('Initializing Real AR with constant size:', modelName);
                
                // Set model data
                modelData = MODEL_CONFIGS[modelName] || MODEL_CONFIGS.array;
                
                // Update UI
                updateUI();

                // Initialize enhanced features
                initTouchGestures();
                updateModelInfo();
                hideGestureHints();
                
                // Initialize camera
                updateProgress(10, 'Initializing camera...');
                await initCamera();
                
                // Initialize 3D scene
                updateProgress(30, 'Setting up Real AR...');
                initThreeJS();
                
                // Load 3D model
                updateProgress(60, 'Loading 3D model...');
                await loadModel(modelName);
                
                // Start render loop
                animate();
                
                // Hide loading screen
                document.getElementById('loading').classList.add('hidden');
                
                // Hide instructions after 12 seconds
                setTimeout(() => {
                    document.getElementById('ar-instructions').classList.add('hidden');
                }, 12000);

                updateProgress(90, 'Finalizing Real AR...');
                updateProgress(100, 'Real AR with constant size ready!');
                
                // Show controls initially
                showControls();
                
            } catch (error) {
                console.error('AR initialization failed:', error);
                showError('Failed to initialize AR experience');
            }
        }

        // Enhanced progress tracking
        function updateProgress(percent, message = '') {
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            
            if (progressFill) {
                progressFill.style.width = percent + '%';
            }
            
            if (progressText && message) {
                progressText.textContent = message;
            }
        }

        // Enhanced touch gesture handling
        function initTouchGestures() {
            const canvas = document.getElementById('ar-canvas');
            
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
            
            // Mouse events for desktop testing
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            
            // Show controls on canvas tap
            canvas.addEventListener('click', function() {
                showControls();
            });
            
            console.log('✅ Real AR gestures initialized');
        }

        function handleTouchStart(event) {
            event.preventDefault();
            touchCount = event.touches.length;
            touchStartTime = Date.now();
            
            // Show controls on touch
            showControls();
            
            if (touchCount === 1) {
                lastTouchX = event.touches[0].clientX;
                lastTouchY = event.touches[0].clientY;
            }
            
            if (touchCount === 2) {
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                touchStartDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
            }
        }

        function handleTouchMove(event) {
            event.preventDefault();
            
            if (touchCount === 1 && event.touches.length === 1) {
                // Single finger drag - rotate model
                const deltaX = event.touches[0].clientX - lastTouchX;
                const deltaY = event.touches[0].clientY - lastTouchY;
                
                const sensitivity = 0.005;
                if (model) {
                    model.rotation.y += deltaX * sensitivity;
                    model.rotation.x += deltaY * sensitivity;
                }
                
                lastTouchX = event.touches[0].clientX;
                lastTouchY = event.touches[0].clientY;
            }
            
            if (touchCount === 2 && event.touches.length === 2) {
                // Two finger pinch - move model near/far with constant visual size
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                const deltaDistance = currentDistance - touchStartDistance;
                const threshold = 20; // Increased threshold for better detection
                
                if (Math.abs(deltaDistance) > threshold) {
                    if (deltaDistance > 0) {
                        // Pinch out - move closer
                        moveNear();
                    } else {
                        // Pinch in - move farther
                        moveFar();
                    }
                    touchStartDistance = currentDistance;
                }
            }
        }

        function handleTouchEnd(event) {
            const touchDuration = Date.now() - touchStartTime;
            
            // Double tap detection
            const currentTime = Date.now();
            const timeDiff = currentTime - lastTouchTime;
            
            if (timeDiff < 300 && timeDiff > 0 && touchDuration < 200) {
                resetView();
                event.preventDefault();
            }
            
            // Long press detection (800ms)
            if (touchDuration > 800 && touchCount === 1) {
                toggleInfoPanel();
            }
            
            lastTouchTime = currentTime;
            touchCount = 0;
        }

        // Mouse events for desktop
        let isMouseDown = false;

        function handleMouseDown(event) {
            isMouseDown = true;
            lastTouchX = event.clientX;
            lastTouchY = event.clientY;
            
            // Show controls on mouse down
            showControls();
        }

        function handleMouseMove(event) {
            if (!isMouseDown) return;
            
            const deltaX = event.clientX - lastTouchX;
            const deltaY = event.clientY - lastTouchY;
            
            const sensitivity = 0.005;
            if (model) {
                model.rotation.y += deltaX * sensitivity;
                model.rotation.x += deltaY * sensitivity;
            }
            
            lastTouchX = event.clientX;
            lastTouchY = event.clientY;
        }

        function handleMouseUp(event) {
            isMouseDown = false;
        }

        // Model movement functions - REAL 3D MOVEMENT with CONSTANT VISUAL SIZE
        function moveModel(direction) {
            stopModelMovement();
            currentModelMovement = direction;
            
            modelMovementInterval = setInterval(() => {
                if (model) {
                    const speed = MODEL_MOVEMENT_SPEED;
                    
                    switch(direction) {
                        case 'up':
                            modelPosition.y += speed;
                            break;
                        case 'down':
                            modelPosition.y -= speed;
                            break;
                        case 'left':
                            modelPosition.x -= speed;
                            break;
                        case 'right':
                            modelPosition.x += speed;
                            break;
                    }
                    
                    // Update model position in 3D space
                    model.position.set(
                        modelPosition.x,
                        modelPosition.y,
                        modelPosition.z
                    );
                    
                    // Update scale to maintain constant visual size
                    updateModelScale();
                }
            }, 16);
        }

        function stopModelMovement() {
            if (modelMovementInterval) {
                clearInterval(modelMovementInterval);
                modelMovementInterval = null;
                currentModelMovement = null;
            }
        }

        // Enhanced model information
        function updateModelInfo() {
            const modelName = Object.keys(MODEL_CONFIGS).find(key => 
                MODEL_CONFIGS[key] === modelData
            );
            
            const enhancedData = ENHANCED_MODEL_DATA[modelName];
            if (!enhancedData) return;
            
            // Update overview
            const overviewContent = document.getElementById('overview-content');
            if (overviewContent) {
                overviewContent.textContent = enhancedData.overview;
            }
            
            // Update components list
            const componentsList = document.getElementById('components-list');
            if (componentsList) {
                componentsList.innerHTML = '';
                enhancedData.components.forEach((component, index) => {
                    const li = document.createElement('li');
                    li.className = 'hotspot-item';
                    li.textContent = component;
                    li.onclick = () => highlightComponent(index);
                    componentsList.appendChild(li);
                });
            }
            
            // Update performance info
            const performanceContent = document.getElementById('performance-content');
            if (performanceContent) {
                performanceContent.innerHTML = `
                    <div><strong>Complexity:</strong> ${enhancedData.performance}</div>
                    <div><strong>Use Cases:</strong> ${enhancedData.useCases}</div>
                `;
            }
        }

        function highlightComponent(index) {
            // Add visual highlight effect to model component
            if (model && model.children[index]) {
                const component = model.children[index];
                
                // Create highlight effect
                const originalMaterial = component.material;
                const highlightMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x667eea,
                    transparent: true,
                    opacity: 0.7
                });
                
                component.material = highlightMaterial;
                
                setTimeout(() => {
                    component.material = originalMaterial;
                }, 2000);
            }
        }

        // Show toast notification
        function showToast(message, duration = 3000) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, duration);
        }

        // Enhanced screenshot with AR background - Save to gallery
        function captureARScreenshot() {
            try {
                const video = document.getElementById('camera-feed');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                // Draw camera feed as background
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // Draw 3D scene on top
                ctx.globalCompositeOperation = 'source-over';
                ctx.drawImage(renderer.domElement, 0, 0);
                
                // Convert to blob
                canvas.toBlob(function(blob) {
                    // Save to gallery using ReactNative bridge
                    if (window.ReactNativeWebView) {
                        const filename = `RealAR_${modelData.title.replace(/\s+/g, '_')}_${Date.now()}.png`;
                        const folderPath = AR_CONFIG.SCREENSHOT_FOLDER;
                        
                        // Convert blob to base64
                        const reader = new FileReader();
                        reader.readAsDataURL(blob);
                        reader.onloadend = function() {
                            const base64data = reader.result;
                            
                            // Send to React Native to save in gallery
                            window.ReactNativeWebView.postMessage(JSON.stringify({
                                type: 'save_screenshot',
                                data: base64data,
                                filename: filename,
                                folderPath: folderPath
                            }));
                            
                            // Show success message
                            showToast(`Screenshot saved`);
                        };
                    } else {
                        // Fallback for web
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.download = `RealAR_${modelData.title.replace(/\s+/g, '_')}_${Date.now()}.png`;
                        link.href = url;
                        link.click();
                        URL.revokeObjectURL(url);
                        
                        showToast('Screenshot saved');
                    }
                    
                    // Visual feedback
                    const button = event.target.closest('.control-btn');
                    button.style.background = 'rgba(76, 175, 80, 0.8)';
                    
                    setTimeout(() => {
                        button.style.background = '';
                    }, 1000);
                    
                }, 'image/png');
                
            } catch (error) {
                console.error('Screenshot error:', error);
                showToast('Failed to save screenshot', 3000);
            }
        }

        // Toggle info panel
        function toggleInfoPanel() {
            const panel = document.getElementById('info-panel');
            panel.classList.toggle('hidden');
        }

        // Hide gesture hints after delay
        function hideGestureHints() {
            setTimeout(() => {
                const hints = document.getElementById('gesture-hints');
                if (hints) {
                    hints.classList.add('hidden');
                }
            }, 18000); // Hide after 18 seconds
        }
        
        async function initCamera() {
            try {
                const video = document.getElementById('camera-feed');
                
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('Camera not supported');
                }
                
                cameraStream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
                
                video.srcObject = cameraStream;
                
                return new Promise((resolve, reject) => {
                    video.onloadedmetadata = () => {
                        video.play().then(resolve).catch(reject);
                    };
                    video.onerror = reject;
                });
                
            } catch (error) {
                console.error('Camera initialization failed:', error);
                throw new Error('Camera access denied');
            }
        }
        
        function initThreeJS() {
            const canvas = document.getElementById('ar-canvas');
            
            // Scene
            scene = new THREE.Scene();
            
            // Camera setup - REAL AR CAMERA
            camera = new THREE.PerspectiveCamera(
                AR_CONFIG.CAMERA_FOV, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                1000
            );
            
            // Set camera position - FIXED LIKE REAL AR
            camera.position.set(
                AR_CONFIG.CAMERA_POSITION.x,
                AR_CONFIG.CAMERA_POSITION.y,
                AR_CONFIG.CAMERA_POSITION.z
            );
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                alpha: true,
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // PROFESSIONAL LIGHTING SETUP
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            scene.add(directionalLight);
            
            // Additional fill lights
            const fillLight1 = new THREE.DirectionalLight(0xffffff, 0.4);
            fillLight1.position.set(-5, 5, -5);
            scene.add(fillLight1);
            
            const fillLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight2.position.set(0, -5, 5);
            scene.add(fillLight2);
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            console.log('✅ Real AR setup complete');
        }
        
        async function loadModel(modelName) {
            return new Promise((resolve, reject) => {
                const loader = new THREE.GLTFLoader();
                
                console.log('Loading model from:', modelData.model);
                
                loader.load(
                    modelData.model,
                    (gltf) => {
                        model = gltf.scene;
                        
                        // Initialize model position - REAL 3D POSITION
                        modelPosition = { ...AR_CONFIG.INITIAL_MODEL_POSITION };
                        
                        // Set model position in 3D space
                        model.position.set(
                            modelPosition.x,
                            modelPosition.y,
                            modelPosition.z
                        );
                        
                        // Set initial scale for constant visual size
                        model.scale.setScalar(AR_CONFIG.BASE_MODEL_SCALE);
                        
                        // Set initial rotation
                        model.rotation.set(0, 0, 0);
                        
                        // Enable shadows and enhance materials
                        model.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                
                                // Enhance material for professional look
                                if (child.material) {
                                    child.material.roughness = 0.6;
                                    child.material.metalness = 0.2;
                                    child.material.envMapIntensity = 1.0;
                                }
                            }
                        });
                        
                        // Add to scene
                        scene.add(model);
                        
                        // Initialize scale for constant visual size
                        updateModelScale();
                        
                        console.log('✅ Model loaded with constant visual size system');
                        console.log('✅ Initial position:', model.position);
                        console.log('✅ Initial scale:', model.scale);
                        
                        // Send message to React Native
                        if (window.ReactNativeWebView) {
                            window.ReactNativeWebView.postMessage(JSON.stringify({
                                type: 'model_loaded',
                                modelName: modelName
                            }));
                        }
                        
                        resolve();
                    },
                    (progress) => {
                        console.log('Loading progress:', progress);
                    },
                    (error) => {
                        console.error('Model loading failed:', error);
                        createFallbackModel(modelName);
                        resolve();
                    }
                );
            });
        }
        
        function createFallbackModel(modelName) {
            let geometry, material;
            
            switch(modelName) {
                case 'array':
                    const group = new THREE.Group();
                    for(let i = 0; i < 7; i++) {
                        const boxGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
                        const boxMaterial = new THREE.MeshStandardMaterial({ 
                            color: new THREE.Color().setHSL(i * 0.15, 0.7, 0.6),
                            roughness: 0.6,
                            metalness: 0.2
                        });
                        const box = new THREE.Mesh(boxGeometry, boxMaterial);
                        box.position.x = (i - 3) * 0.5;
                        box.castShadow = true;
                        box.receiveShadow = true;
                        group.add(box);
                    }
                    model = group;
                    break;
                    
                case 'osi_model':
                    const osiGroup = new THREE.Group();
                    const colors = [0xff4444, 0xff8844, 0xffcc44, 0x44ff44, 0x44ccff, 0x4444ff, 0x8844ff];
                    for(let i = 0; i < 7; i++) {
                        const layerGeometry = new THREE.BoxGeometry(1.2, 0.2, 0.8);
                        const layerMaterial = new THREE.MeshStandardMaterial({ 
                            color: colors[i],
                            roughness: 0.6,
                            metalness: 0.2
                        });
                        const layer = new THREE.Mesh(layerGeometry, layerMaterial);
                        layer.position.y = i * 0.25 - 0.75;
                        layer.castShadow = true;
                        layer.receiveShadow = true;
                        osiGroup.add(layer);
                    }
                    model = osiGroup;
                    break;
                    
                default:
                    geometry = new THREE.BoxGeometry(1, 1, 1);
                    material = new THREE.MeshStandardMaterial({ 
                        color: 0x9C27B0,
                        roughness: 0.6,
                        metalness: 0.2
                    });
                    model = new THREE.Mesh(geometry, material);
                    model.castShadow = true;
                    model.receiveShadow = true;
                    break;
            }
            
            // Initialize model position - REAL 3D POSITION
            modelPosition = { ...AR_CONFIG.INITIAL_MODEL_POSITION };
            
            // Set model position in 3D space
            model.position.set(
                modelPosition.x,
                modelPosition.y,
                modelPosition.z
            );
            
            // Set initial scale for constant visual size
            model.scale.setScalar(AR_CONFIG.BASE_MODEL_SCALE);
            
            // Set initial rotation
            model.rotation.set(0, 0, 0);
            
            scene.add(model);
            
            // Initialize scale for constant visual size
            updateModelScale();
            
            console.log('✅ Fallback model created with constant visual size system');
        }
        
        function updateUI() {
            document.getElementById('model-title').textContent = modelData.title;
            document.getElementById('model-subtitle').textContent = modelData.subtitle;
            updateModelInfo();
        }
        
        // Rotation functions - Rotate the MODEL
        function startRotation(direction) {
            stopRotation();
            currentRotationDirection = direction;
            
            rotationInterval = setInterval(() => {
                if (model) {
                    switch(direction) {
                        case 'up':
                            model.rotation.x -= ROTATION_SPEED;
                            break;
                        case 'down':
                            model.rotation.x += ROTATION_SPEED;
                            break;
                        case 'left':
                            model.rotation.y += ROTATION_SPEED;
                            break;
                        case 'right':
                            model.rotation.y -= ROTATION_SPEED;
                            break;
                    }
                }
            }, 16);
        }
        
        function stopRotation() {
            if (rotationInterval) {
                clearInterval(rotationInterval);
                rotationInterval = null;
                currentRotationDirection = null;
            }
        }
        
        // REAL AR DISTANCE CONTROLS with CONSTANT VISUAL SIZE - ORIGINAL FUNCTIONALITY
        function moveNear() {
            try {
                if (model) {
                    // Move model closer in 3D space
                    modelPosition.z += AR_CONFIG.NEAR_FAR_INCREMENT;
                    
                    // Limit how close the model can get
                    if (modelPosition.z > -2) {
                        modelPosition.z = -2;
                    }
                    
                    model.position.z = modelPosition.z;
                    
                    // Update scale to maintain constant visual size
                    updateModelScale();
                }
            } catch (error) {
                console.error('Move near error:', error);
            }
        }

        function moveFar() {
            try {
                if (model) {
                    // Move model farther in 3D space
                    modelPosition.z -= AR_CONFIG.NEAR_FAR_INCREMENT;
                    
                    // Limit how far the model can go
                    if (modelPosition.z < -50) {
                        modelPosition.z = -50;
                    }
                    
                    model.position.z = modelPosition.z;
                    
                    // Update scale to maintain constant visual size
                    updateModelScale();
                }
            } catch (error) {
                console.error('Move far error:', error);
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Auto rotation of the MODEL
            if (model && isAutoRotating) {
                model.rotation.y += AR_CONFIG.ROTATION_SPEED;
            }
            
            // Render the scene
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function resetView() {
            try {
                if (model) {
                    // Reset model rotation
                    model.rotation.set(0, 0, 0);
                    
                    // Reset model position to initial 3D position
                    modelPosition = { ...AR_CONFIG.INITIAL_MODEL_POSITION };
                    model.position.set(
                        modelPosition.x,
                        modelPosition.y,
                        modelPosition.z
                    );
                    
                    // Reset scale for constant visual size
                    updateModelScale();
                    
                    showToast('View reset');
                }
            } catch (error) {
                console.error('Reset error:', error);
            }
        }
        
        function closeAR() {
            try {
                stopRotation();
                stopModelMovement();
                if (cameraStream) {
                    cameraStream.getTracks().forEach(track => track.stop());
                }
                if (window.ReactNativeWebView) {
                    window.ReactNativeWebView.postMessage(JSON.stringify({
                        type: 'close_ar'
                    }));
                }
            } catch (error) {
                console.error('Close AR error:', error);
            }
        }
        
        function showError(message) {
            document.getElementById('loading').classList.add('hidden');
            const errorDiv = document.getElementById('error');
            if (errorDiv) {
                const errorText = errorDiv.querySelector('div');
                if (errorText) {
                    errorText.textContent = message;
                }
                errorDiv.classList.remove('hidden');
            }
        }
        
        // Handle messages from React Native
        window.addEventListener('message', function(event) {
            try {
                const data = JSON.parse(event.data);
                switch(data.type) {
                    case 'change_model':
                        changeModel(data.modelName);
                        break;
                    case 'reset_view':
                        resetView();
                        break;
                    case 'screenshot_saved':
                        showToast('Screenshot saved');
                        break;
                }
            } catch (error) {
                console.error('Error handling message:', error);
            }
        });
        
        async function changeModel(newModelName) {
            try {
                if (model) {
                    scene.remove(model);
                }
                
                modelData = MODEL_CONFIGS[newModelName] || MODEL_CONFIGS.array;
                updateUI();
                await loadModel(newModelName);
            } catch (error) {
                console.error('Change model error:', error);
            }
        }
        
        // Error handling
        window.addEventListener('error', function(event) {
            console.error('Real AR Error:', event.error);
            if (!event.error.message.includes('camera')) {
                showError('An error occurred in AR view');
            }
        });
        
        // Handle page visibility change
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                stopRotation();
                stopModelMovement();
                if (cameraStream) {
                    cameraStream.getTracks().forEach(track => track.enabled = false);
                }
            } else {
                if (cameraStream) {
                    cameraStream.getTracks().forEach(track => track.enabled = true);
                }
            }
        });
        
        // Prevent default touch events on buttons
        document.addEventListener('touchstart', function(e) {
            if (e.target.classList.contains('control-btn') || 
                e.target.classList.contains('rotation-btn') ||
                e.target.classList.contains('panel-btn') ||
                e.target.classList.contains('controls-toggle')) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html>