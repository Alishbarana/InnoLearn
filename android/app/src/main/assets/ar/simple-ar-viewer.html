<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple AR Viewer</title>
    
    <!-- Three.js for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }
        
        #camera-feed {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            z-index: 1;
        }
        
        #ar-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 2;
            pointer-events: auto;
        }
        
        .ar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
        }
        
        .ar-header {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            z-index: 4;
        }
        
        .ar-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .ar-subtitle {
            font-size: 14px;
            opacity: 0.8;
        }
        
        .ar-controls {
            position: fixed;
            bottom: 30px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-around;
            pointer-events: auto;
            z-index: 4;
        }
        
        .ar-button {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 50px;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            min-width: 60px;
        }
        
        .ar-button:hover {
            background: rgba(0, 0, 0, 0.9);
        }
        
        .ar-button:active {
            transform: scale(0.95);
        }
        
        .ar-instructions {
            position: fixed;
            bottom: 120px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 14px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            z-index: 4;
            opacity: 1;
            transition: opacity 0.5s ease;
        }
        
        .ar-instructions.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 5;
        }
        
        .error {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 5;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Camera Feed -->
    <video id="camera-feed" autoplay muted playsinline></video>
    
    <!-- 3D Canvas -->
    <canvas id="ar-canvas"></canvas>
    
    <!-- Loading Screen -->
    <div id="loading" class="loading">
        <div>Loading AR Experience...</div>
        <div style="margin-top: 10px; font-size: 12px;">Initializing camera and 3D model...</div>
    </div>
    
    <!-- Error Screen -->
    <div id="error" class="error hidden">
        <div>Camera Access Required</div>
        <div style="margin-top: 10px; font-size: 12px;">Please allow camera access for AR</div>
    </div>
    
    <!-- AR Overlay -->
    <div class="ar-overlay">
        <!-- Header Info -->
        <div class="ar-header">
            <div class="ar-title" id="model-title">Loading...</div>
            <div class="ar-subtitle" id="model-subtitle">Model is fixed in space - move your camera around it</div>
        </div>
        
        <!-- Instructions -->
        <div id="ar-instructions" class="ar-instructions">
            Model is positioned in front of you - use controls to rotate manually
        </div>
        
        <!-- Controls -->
        <div class="ar-controls">
            <button class="ar-button" onclick="resetModel()">
                <span>üîÑ</span>
                <span>Reset</span>
            </button>
            <button class="ar-button" onclick="rotateModel()">
                <span>üîÑ</span>
                <span>Rotate</span>
            </button>
            <button class="ar-button" onclick="changeSize()">
                <span id="size-icon">üìè</span>
                <span id="size-text">Size</span>
            </button>
            <button class="ar-button" onclick="closeAR()">
                <span>‚ùå</span>
                <span>Close</span>
            </button>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, model;
        let currentSize = 1;
        let modelData = {};
        let cameraStream = null;
        
        // üéØ MAIN CONFIGURATION - CHANGE THESE VALUES FOR YOUR DESIRED OUTPUT
        const AR_CONFIG = {
            // Model positioning (change these to adjust where model appears)
            MODEL_DISTANCE: -1.5,     // How far from camera (negative = in front)
            MODEL_HEIGHT: 0,          // Height offset (0 = center, positive = up)
            MODEL_SIDE: 0,            // Side offset (0 = center, positive = right)
            
            // Model sizing
            INITIAL_SCALE: 1.0,       // Starting size (1.0 = normal, 0.5 = half, 2.0 = double)
            
            // Camera settings
            CAMERA_FOV: 75,           // Field of view (75 = normal, 90 = wider, 60 = narrower)
            
            // Auto rotation
            AUTO_ROTATE: false,       // true = model rotates automatically, false = manual only
            ROTATION_SPEED: 0.01      // Speed of auto rotation (if enabled)
        };
        
        // Model configurations with your actual .glb files
        const MODEL_CONFIGS = {
            array: {
                title: "Array Data Structure",
                subtitle: "Linear collection of elements with indexed access",
                model: "file:///android_asset/models/array.glb",
                scale: AR_CONFIG.INITIAL_SCALE,
                // üéØ EXACT POSITION - Model appears directly in front of camera
                position: { 
                    x: AR_CONFIG.MODEL_SIDE, 
                    y: AR_CONFIG.MODEL_HEIGHT, 
                    z: AR_CONFIG.MODEL_DISTANCE 
                }
            },
            binary_tree: {
                title: "Binary Tree",
                subtitle: "Hierarchical structure with parent-child relationships",
                model: "file:///android_asset/models/binary_tree.glb",
                scale: AR_CONFIG.INITIAL_SCALE,
                position: { 
                    x: AR_CONFIG.MODEL_SIDE, 
                    y: AR_CONFIG.MODEL_HEIGHT, 
                    z: AR_CONFIG.MODEL_DISTANCE 
                }
            },
            linked_list: {
                title: "Linked List",
                subtitle: "Sequential nodes connected via pointers",
                model: "file:///android_asset/models/linked_list.glb",
                scale: AR_CONFIG.INITIAL_SCALE,
                position: { 
                    x: AR_CONFIG.MODEL_SIDE, 
                    y: AR_CONFIG.MODEL_HEIGHT, 
                    z: AR_CONFIG.MODEL_DISTANCE 
                }
            },
            stack: {
                title: "Stack (LIFO)",
                subtitle: "Last In First Out data structure",
                model: "file:///android_asset/models/stack.glb",
                scale: AR_CONFIG.INITIAL_SCALE,
                position: { 
                    x: AR_CONFIG.MODEL_SIDE, 
                    y: AR_CONFIG.MODEL_HEIGHT, 
                    z: AR_CONFIG.MODEL_DISTANCE 
                }
            },
            queue: {
                title: "Queue (FIFO)",
                subtitle: "First In First Out data structure",
                model: "file:///android_asset/models/queue.glb",
                scale: AR_CONFIG.INITIAL_SCALE,
                position: { 
                    x: AR_CONFIG.MODEL_SIDE, 
                    y: AR_CONFIG.MODEL_HEIGHT, 
                    z: AR_CONFIG.MODEL_DISTANCE 
                }
            },
            merge_sort: {
                title: "Merge Sort Algorithm",
                subtitle: "Divide and conquer sorting technique",
                model: "file:///android_asset/models/merge_sort.glb",
                scale: AR_CONFIG.INITIAL_SCALE,
                position: { 
                    x: AR_CONFIG.MODEL_SIDE, 
                    y: AR_CONFIG.MODEL_HEIGHT, 
                    z: AR_CONFIG.MODEL_DISTANCE 
                }
            },
            osi_model: {
                title: "OSI Model",
                subtitle: "7-layer network communication framework",
                model: "file:///android_asset/models/osi_model.glb",
                scale: AR_CONFIG.INITIAL_SCALE,
                position: { 
                    x: AR_CONFIG.MODEL_SIDE, 
                    y: AR_CONFIG.MODEL_HEIGHT, 
                    z: AR_CONFIG.MODEL_DISTANCE 
                }
            },
            client_server: {
                title: "Client-Server Architecture",
                subtitle: "Distributed computing model",
                model: "file:///android_asset/models/client_server.glb",
                scale: AR_CONFIG.INITIAL_SCALE,
                position: { 
                    x: AR_CONFIG.MODEL_SIDE, 
                    y: AR_CONFIG.MODEL_HEIGHT, 
                    z: AR_CONFIG.MODEL_DISTANCE 
                }
            },
            firewall: {
                title: "Network Firewall",
                subtitle: "Security barrier for network traffic",
                model: "file:///android_asset/models/firewall.glb",
                scale: AR_CONFIG.INITIAL_SCALE,
                position: { 
                    x: AR_CONFIG.MODEL_SIDE, 
                    y: AR_CONFIG.MODEL_HEIGHT, 
                    z: AR_CONFIG.MODEL_DISTANCE 
                }
            },
            router: {
                title: "Network Router",
                subtitle: "Data packet forwarding device",
                model: "file:///android_asset/models/router.glb",
                scale: AR_CONFIG.INITIAL_SCALE,
                position: { 
                    x: AR_CONFIG.MODEL_SIDE, 
                    y: AR_CONFIG.MODEL_HEIGHT, 
                    z: AR_CONFIG.MODEL_DISTANCE 
                }
            }
        };
        
        // Initialize AR
        document.addEventListener('DOMContentLoaded', function() {
            initializeAR();
        });
        
        async function initializeAR() {
            try {
                // Get model name from URL parameters
                const urlParams = new URLSearchParams(window.location.search);
                const modelName = urlParams.get('model') || 'array';
                const confidence = urlParams.get('confidence') || '95';
                
                console.log('Initializing AR with model:', modelName);
                
                // Set model data
                modelData = MODEL_CONFIGS[modelName] || MODEL_CONFIGS.array;
                
                // Update UI
                updateUI();
                
                // Initialize camera
                await initCamera();
                
                // Initialize 3D scene
                initThreeJS();
                
                // Load 3D model from assets
                await loadModel(modelName);
                
                // Start render loop
                animate();
                
                // Hide loading screen
                document.getElementById('loading').classList.add('hidden');
                
                // Hide instructions after 4 seconds
                setTimeout(() => {
                    document.getElementById('ar-instructions').classList.add('hidden');
                }, 4000);
                
            } catch (error) {
                console.error('AR initialization failed:', error);
                showError('Failed to initialize AR experience');
            }
        }
        
        async function initCamera() {
            try {
                const video = document.getElementById('camera-feed');
                
                // Request camera access
                cameraStream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'environment', // Use back camera
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
                
                video.srcObject = cameraStream;
                
                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resolve();
                    };
                });
                
            } catch (error) {
                console.error('Camera initialization failed:', error);
                throw new Error('Camera access denied');
            }
        }
        
        function initThreeJS() {
            const canvas = document.getElementById('ar-canvas');
            
            // Scene
            scene = new THREE.Scene();
            
            // üéØ CAMERA SETUP - Fixed position for true AR
            camera = new THREE.PerspectiveCamera(
                AR_CONFIG.CAMERA_FOV, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                1000
            );
            // Camera stays at origin (0,0,0) - like real AR
            camera.position.set(0, 0, 0);
            camera.lookAt(0, 0, -1); // Look forward
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                alpha: true,
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0); // Transparent background
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // üéØ LIGHTING SETUP - Good visibility for AR
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(2, 2, 2);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // üéØ NO CONTROLS - Pure AR experience (camera doesn't move)
            // No OrbitControls = camera stays fixed like real AR
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }
        
        async function loadModel(modelName) {
            return new Promise((resolve, reject) => {
                const loader = new THREE.GLTFLoader();
                
                console.log('Loading model from:', modelData.model);
                
                loader.load(
                    modelData.model,
                    (gltf) => {
                        model = gltf.scene;
                        
                        // üéØ MODEL POSITIONING - Exactly where you want it
                        model.scale.setScalar(modelData.scale * currentSize);
                        model.position.set(
                            modelData.position.x,
                            modelData.position.y,
                            modelData.position.z
                        );
                        
                        // üéØ MODEL ORIENTATION - Face the user directly
                        model.rotation.set(0, 0, 0); // Face forward
                        
                        // Enable shadows
                        model.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });
                        
                        // Add to scene
                        scene.add(model);
                        
                        console.log('Model loaded and positioned at:', model.position);
                        console.log('Model scale:', model.scale);
                        
                        // Send message to React Native
                        if (window.ReactNativeWebView) {
                            window.ReactNativeWebView.postMessage(JSON.stringify({
                                type: 'model_loaded',
                                modelName: modelName
                            }));
                        }
                        
                        resolve();
                    },
                    (progress) => {
                        console.log('Loading progress:', progress);
                    },
                    (error) => {
                        console.error('Model loading failed:', error);
                        
                        // Fallback to simple geometry if model fails to load
                        console.log('Creating fallback geometry for:', modelName);
                        createFallbackModel(modelName);
                        resolve();
                    }
                );
            });
        }
        
        function createFallbackModel(modelName) {
            // Create simple geometric representations as fallback
            let geometry, material;
            
            switch(modelName) {
                case 'array':
                    const group = new THREE.Group();
                    for(let i = 0; i < 5; i++) {
                        const boxGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                        const boxMaterial = new THREE.MeshLambertMaterial({ color: 0x4CAF50 });
                        const box = new THREE.Mesh(boxGeometry, boxMaterial);
                        box.position.x = (i - 2) * 0.25;
                        box.castShadow = true;
                        group.add(box);
                    }
                    model = group;
                    break;
                    
                case 'stack':
                    const stackGroup = new THREE.Group();
                    for(let i = 0; i < 4; i++) {
                        const boxGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.3);
                        const boxMaterial = new THREE.MeshLambertMaterial({ color: 0xFF9800 });
                        const box = new THREE.Mesh(boxGeometry, boxMaterial);
                        box.position.y = i * 0.12;
                        box.castShadow = true;
                        stackGroup.add(box);
                    }
                    model = stackGroup;
                    break;
                    
                case 'binary_tree':
                    const treeGroup = new THREE.Group();
                    const rootGeometry = new THREE.SphereGeometry(0.1, 16, 16);
                    const rootMaterial = new THREE.MeshLambertMaterial({ color: 0x2196F3 });
                    
                    // Root
                    const root = new THREE.Mesh(rootGeometry, rootMaterial);
                    root.position.y = 0.2;
                    treeGroup.add(root);
                    
                    // Left child
                    const leftChild = new THREE.Mesh(rootGeometry, rootMaterial);
                    leftChild.position.set(-0.2, 0, 0);
                    treeGroup.add(leftChild);
                    
                    // Right child
                    const rightChild = new THREE.Mesh(rootGeometry, rootMaterial);
                    rightChild.position.set(0.2, 0, 0);
                    treeGroup.add(rightChild);
                    
                    model = treeGroup;
                    break;
                    
                default:
                    geometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                    material = new THREE.MeshLambertMaterial({ color: 0x9C27B0 });
                    model = new THREE.Mesh(geometry, material);
                    break;
            }
            
            // üéØ FALLBACK MODEL POSITIONING
            model.scale.setScalar(modelData.scale * currentSize);
            model.position.set(
                modelData.position.x,
                modelData.position.y,
                modelData.position.z
            );
            model.rotation.set(0, 0, 0); // Face forward
            
            // Enable shadows
            model.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            
            // Add to scene
            scene.add(model);
            
            console.log('Fallback model created and positioned:', modelName);
        }
        
        function updateUI() {
            document.getElementById('model-title').textContent = modelData.title;
            document.getElementById('model-subtitle').textContent = modelData.subtitle;
        }

        function changeSize() {
            if (model) {
                // Cycle through sizes: 0.5x -> 1x -> 1.5x -> 2x -> back to 0.5x
                if (currentSize <= 0.5) {
                    currentSize = 1;
                } else if (currentSize <= 1) {
                    currentSize = 1.5;
                } else if (currentSize <= 1.5) {
                    currentSize = 2;
                } else {
                    currentSize = 0.5;
                }
                
                model.scale.setScalar(modelData.scale * currentSize);
                
                // Update button text
                const sizeText = document.getElementById('size-text');
                sizeText.textContent = `${currentSize}x`;
                
                // Reset text after 2 seconds
                setTimeout(() => {
                    sizeText.textContent = 'Size';
                }, 2000);
            }
        }

        function rotateModel() {
            if (model) {
                // Rotate model by 45 degrees on Y axis
                model.rotation.y += Math.PI / 4; // 45 degrees in radians
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // üéØ AUTO ROTATION (if enabled in config)
            if (model && AR_CONFIG.AUTO_ROTATE) {
                model.rotation.y += AR_CONFIG.ROTATION_SPEED;
            }
            
            // üéØ RENDER - No camera controls, pure AR
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Control functions
        function resetModel() {
            if (model) {
                // üéØ RESET TO ORIGINAL POSITION
                model.rotation.set(0, 0, 0);
                model.position.set(
                    modelData.position.x,
                    modelData.position.y,
                    modelData.position.z
                );
                model.scale.setScalar(modelData.scale * currentSize);
                
                console.log('Model reset to position:', model.position);
            }
        }
        
        function closeAR() {
            // Stop camera stream
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
            }
            
            // Send message to React Native
            if (window.ReactNativeWebView) {
                window.ReactNativeWebView.postMessage(JSON.stringify({
                    type: 'close_ar'
                }));
            }
        }
        
        function showError(message) {
            document.getElementById('loading').classList.add('hidden');
            const errorDiv = document.getElementById('error');
            errorDiv.querySelector('div').textContent = message;
            errorDiv.classList.remove('hidden');
        }
        
        // Handle messages from React Native
        window.addEventListener('message', function(event) {
            try {
                const data = JSON.parse(event.data);
                
                switch(data.type) {
                    case 'change_model':
                        changeModel(data.modelName);
                        break;
                    case 'reset_view':
                        resetModel();
                        break;
                }
            } catch (error) {
                console.error('Error handling message:', error);
            }
        });
        
        async function changeModel(newModelName) {
            if (model) {
                scene.remove(model);
            }
            
            modelData = MODEL_CONFIGS[newModelName] || MODEL_CONFIGS.array;
            updateUI();
            await loadModel(newModelName);
        }
        
        // Error handling
        window.addEventListener('error', function(event) {
            console.error('AR Error:', event.error);
            showError('An error occurred in AR view');
        });
        
        // Handle page visibility change
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                if (cameraStream) {
                    cameraStream.getTracks().forEach(track => track.enabled = false);
                }
            } else {
                if (cameraStream) {
                    cameraStream.getTracks().forEach(track => track.enabled = true);
                }
            }
        });
    </script>
</body>
</html>
